diff --git a/include/assembly.h b/include/assembly.h
--- include/assembly.h
+++ include/assembly.h
@@ -15,9 +15,9 @@

 DEFINE_EXCEPTION(AssemblyError)

 struct Label {
-  std::string name;
+  char c;
   s64 offset;
   unsigned line;
 };

@@ -36,29 +36,16 @@

   Section(const Section &) = delete;
   Section &operator=(const Section &) = delete;

-  Label *findLabelB(const std::string &name, unsigned line) {
-    auto r = std::ranges::find_last_if(
-        labels.begin(), labels.end(), [&name, line](const Label &label) {
-          return label.name == name && label.line < line;
-        });
-    return r.empty() ? nullptr : &*r.begin();
-  }
+  const Label *findLabelB(char c, unsigned line);
+  const Label *findLabelF(char c, unsigned line);

-  Label *findLabelF(const std::string &name, unsigned line) {
-    auto r = std::ranges::find_last_if(
-        labels.rbegin(), labels.rend(), [&name, line](const Label &label) {
-          return label.name == name && label.line > line;
-        });
-    return r.empty() ? nullptr : &*r.begin();
-  }
-
   std::string name;
   s64 offset = 0;
   u8 align = 3;

-  std::list<Label> labels;
+  std::vector<Label> labels;
   std::list<Instr> instrs;
   std::list<Directive> directives;
 };

@@ -87,38 +74,28 @@
   s64 offset = 0;
 };

 struct Expr {
-  Expr() {}
+  enum Type { Int, Sym, Func};

-  s64 i;
+  Expr(s64 i) : i(i), type(Int) {}
+  Expr(const std::string &s, Type type = Sym) : s(s), type(type) {}

-  std::string sym;
+  Type type;

-  std::string func;
+  s64 i;
+  std::string s;
   std::vector<std::unique_ptr<Expr>> arguments;
 };

 struct ExprToken {
-  enum Type { Int, Sym, LPar, RPar, Func };
+  enum Type { Int, Sym, LPar, RPar, Func, Err };

+  Type type;
   s64 i;
   std::string s;
 };

-class ExprLexer {
-public:
-  ExprLexer(const std::string &s) : s(s) {}
-
-  bool hasNext();
-  void next();
-
-private:
-  std::string s;
-};
-
-// ExprParser
-
 class Assembler {
 public:
   explicit Assembler(std::string filename)
       : filename(filename), writer(filename + ".o", elf::ET_REL) {}
@@ -145,21 +122,33 @@
   }

   bool isSpace(char c) { return isOneOf(c, "\t "); }

-  bool isOperator(char c) { return isOneOf(c, "+-*/%()<>|&^~"); }
+  bool isOperatorChar(char c) { return isOneOf(c, "+-*/%()<>|&^~"); }

+  bool isSymbolChar(char c) { return isAlpha(c) || isDigit(c) || isOneOf(c, "_."); }
+
   void tokenize(std::vector<std::string> &tokens);

   void parseDirective(const std::vector<std::string> &tokens);
   void parseLabel(const std::vector<std::string> &tokens);
   void parseInstr(const std::vector<std::string> &tokens);

+  void tokenizeExpr(std::string s, std::vector<ExprToken> &tokens);
+  std::unique_ptr<Expr> parseExpr(const std::vector<ExprToken> &tokens);
+  std::unique_ptr<Expr> parseExpr(const std::string &s);
+  ExprVal evalExpr(const Expr *expr);
+
+  s64 parseInt(std::string s);
+  s64 parseInt(char c, bool hex = false);
+
   Section *getSection(const std::string &name);

   Symbol *getSymbol(const std::string &name);
   Symbol *addSymbol(const std::string &name);

+  bool isLocalSymbolName(const std::string &name) { return name.starts_with(".L"); }
+
   std::vector<std::string> lines;
   unsigned curLine = 0;

   Section sections[4] = {Section(".text"), Section(".rodata"), Section(".data"),
@@ -176,19 +165,4 @@

 } // namespace assembly

 #endif
-
-/*
-register x0
-imm .
-
-expression
-+ - * / %
-| & ^ ~
-*/
-
-/*
-1:
-        auipc	a0, %pcrel_hi(msg + 1)
-        addi	a0, a0, %pcrel_lo(1b)
-*/
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -3,9 +3,9 @@
     VERSION 0.1.0
     LANGUAGES C CXX
 )

-set(CMAKE_CXX_STANDARD 23)
+set(CMAKE_CXX_STANDARD 20)
 set(CMAKE_CXX_STANDARD_REQUIRED True)

 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

diff --git a/lib/assembly.cpp b/lib/assembly.cpp
--- lib/assembly.cpp
+++ lib/assembly.cpp
@@ -1,14 +1,16 @@
 #include "assembly.h"

+#include <algorithm>
 #include <fstream>
+#include <functional>

 namespace assembly {

-#define INVALID_SYMBOL()                                                       \
-  THROW(AssemblyError, "invalid symbol", curLine + 1, lines[curLine])
+#define INVALID_SYMBOL_NAME(name)                                                       \
+  THROW(AssemblyError, "invalid symbol", curLine + 1, name)

-#define DUPLICATED_SYMBOL()                                                    \
+#define DUPLICATED_SYMBOL_NAME()                                                    \
   THROW(AssemblyError, "duplicated symbol", curLine + 1, lines[curLine])

 #define UNKNOWN_SECTION_NAME()                                                 \
   THROW(AssemblyError, "unknown section name", curLine + 1, lines[curLine])
@@ -27,8 +29,26 @@

 #define UNKNOWN_DIRECTIVE()                                                    \
   THROW(AssemblyError, "unknown directive", curLine + 1, lines[curLine])

+const Label *Section::findLabelB(char c, unsigned line) {
+  auto it = std::lower_bound(labels.begin(), labels.end(),
+    [](const Label &a, const Label &b) { return a.line < b.line; });
+  while (--it >= labels.begin())
+    if (it->c == c)
+      return &*it;
+  return nullptr;
+}
+
+const Label *Section::findLabelF(char c, unsigned line) {
+  auto it = std::lower_bound(labels.begin(), labels.end(),
+    [](const Label &a, const Label &b) { return a.line <= b.line; });
+  while (it < labels.end())
+    if (it->c == c)
+      return &*it;
+  return nullptr;
+}
+
 void Assembler::run() {
   {
     std::fstream ifs(filename, std::ios::in | std::ios::binary);
     if (!ifs)
@@ -50,22 +70,226 @@
       parseInstr(tokens);
   }
 }

+s64 Assembler::parseInt(char c, bool hex) {
+  if (isDigit(c))
+    return c - '0';
+  if (hex && isOneOf(c, "abcdef"))
+    return c - 'a';
+  UNREACHABLE();
+}
+
+s64 Assembler::parseInt(std::string s) {
+  bool hex = false;
+  if (s.starts_with("0x")) {
+    s = substr(s, 2);
+    hex = true;
+  }
+  s64 res = 0;
+  for (char c : s) {
+    res *= hex ? 16 : 10;
+    res += parseInt(c, hex);
+  }
+  return res;
+}
+
+void Assembler::tokenizeExpr(std::string s, std::vector<ExprToken> &tokens) {
+  s += "\n\n";
+
+  enum {
+    Begin,
+    Int,
+    Hex,
+    Sym,
+    Func,
+    End
+  };
+  auto state = Begin;
+  unsigned j = 0;
+  for (unsigned i = 0; i < s.size(); ++i) {
+    char c = s[i];
+
+#define UNEXPECTED_CHAR() \
+  THROW(AssemblyError, "unexpected character", curLine + 1, s, i, c, toHexStr(c, true))
+
+#define INVALID_SYM_TOKEN(tk) \
+  THROW(AssemblyError, "invalid Sym token", curLine + 1, tk)
+
+#define INVALID_INT_TOKEN(tk) \
+  THROW(AssemblyError, "invalid Int token", curLine + 1, tk)
+
+    switch (state) {
+    case Begin:
+      if (isSpace(c))
+        continue;
+      if (isDigit(c)) {
+        j = i;
+        if (c == '0' && i + 1 < s.size() && s[i+1] == 'x') {
+          state = Hex;
+          ++i;
+        } else {
+          state = Int;
+        }
+      } else if (c == '$') {
+        j = i;
+        state = Sym;
+      } else if (isAlpha(c) || isOperatorChar(c) || c == '_') {
+        j = i;
+        state = Func;
+      } else if (c == '\n') {
+        state = End;
+      } else if (c == '(') {
+        toke.push_back({.type = ExprToken::LPar});
+      } else if (c == ')') {
+        toke.push_back({.type = ExprToken::RPar});
+      } else {
+        UNEXPECTED_CHAR();
+      }
+      break;
+    case Int:
+    case Hex:
+      if (isDigit(c))
+        continue;
+      if (state == Hex && isOneOf("abcdef"))
+        continue;
+      if (isSpace(c) || isOneOf(c, "()\n")) {
+        std::string tk = substr(s, j, i);
+        if (tk == "0x")
+          INVALID_INT_TOKEN(tk);
+        tokens.push_back({.type = ExprToken::Int, .i = parseInt(tk)});
+        --i;
+        state = Begin;
+      } else {
+        UNEXPECTED_CHAR();
+      }
+      break;
+    case Sym:
+      if (isSymbolChar(c))
+        continue;
+      if (isSpace(c) || isOneOf(c, "()\n")) {
+        std::string tk = substr(s, j, i);
+        if (tk.size() < 2)
+          INVALID_SYM_TOKEN(tk);
+        if (isDigit(tk[1])) {
+          if (tk.size() != 3 || !isOneOf(tk[2], "bf"))
+            INVALID_SYM_TOKEN(tk);
+        }
+        tokens.push_back({.type = ExprToken::Sym, .s = substr(tk, 1)});
+        --i;
+        state = Begin;
+      } else {
+        UNEXPECTED_CHAR();
+      }
+      break;
+    case Func:
+      if (isAlpha(c) || isOperatorChar(c) || c == '_' || isDigit(c))
+        continue;
+      if (isSpace(c) || isOneOf(c, "()\n")) {
+        tokens.push_back({.type = ExprToken::Func, .s =substr(s, j, i)});
+        --i;
+        state = Begin;
+      } else {
+        UNEXPECTED_CHAR();
+      }
+      break;
+    case End:
+      tokens.push_back({.type = ExprToken::Err);
+      return;
+    }
+  }
+}
+
+std::unique_ptr<Expr> Assembler::parseExpr(const std::string &s) {
+  std::vector<ExprToken> tokens;
+  tokenizeExpr(s, tokens);
+  return parseExpr(tokens);
+}
+
+static std::string formatExprToken(const ExprToken &tk) {
+  switch (tk.type) {
+  case ExprToken::Int:
+    return join("|", "Int", tk.i);
+  case ExprToken::Sym:
+    return join("|", "Sym", tk.s);
+  case ExprToken::LPar:
+    return "(";
+  case ExprToken::RPar:
+    return ")";
+  case ExprToken::Func:
+    return join("|", "Func", tk.s);
+  case ExprToken::Err:
+    return "Err";
+  default:
+    UNREACHABLE();
+  }
+}
+
+std::unique_ptr<Expr> Assembler::parseExpr(const std::vector<ExprToken> &tokens) {
+  unsigned i = 0;
+
+#define UNEXPECTED_TOKEN() \
+  THROW(AssemblyError, "unexpected token", curLine + 1, lines[curLine], formatExprToken(tk))
+
+#define CUR() (tokens[i])
+
+#define ADVANCE() (tokens[i++])
+
+#define EAT(type) \
+  do { const ExprToken &tk = ADVANCE(); if (tk.type != type) UNEXPECTED_TOKEN(); } while (false)
+
+  std::function<std::unique_ptr<Expr>()> parse;
+
+  parse = [&tokens, &i]() -> std::unique_ptr<Expr> {
+    const ExprToken &tk = ADVANCE();
+    switch (tk.type) {
+    case ExprToken::Int:
+      return std::move(std::make_unique<Expr>(tk->i));
+    case ExprToken::Sym:
+      return std::move(std::make_unique<Expr>(tk->s));
+    case ExprToken::Func: {
+      auto expr = std::make_unique<Expr>(tk->s, Expr::Func);
+      EAT(ExprToken::LPar);
+      while (true) {
+        if (CUR().type == ExprToken::RPar) {
+          ADVANCE();
+          break;
+        }
+        expr->arguments.emplace_back(std::move(parse()));
+      }
+      return std::move(expr);
+    }
+    default:
+      UNEXPECTED_TOKEN();
+    }
+  };
+
+  std::unique_ptr<Expr> expr = std::move(parse());
+
+  if (i != tokens.size() - 1)
+    THROW(AssemblyError, "residual tokens", curLine + 1, lines[curLine], formatExprToken(tokens[i]));
+
+  return std::move(expr);
+}
+
+ExprVal Assembler::evalExpr(const Expr *expr) {
+}
+
 Symbol *Assembler::getSymbol(const std::string &name) {
   if (symbols.count(name))
     return symbols[name].get();
   return nullptr;
 }

 Symbol *Assembler::addSymbol(const std::string &name) {
   if (isDigit(name[0]))
-    INVALID_SYMBOL();
+    INVALID_SYMBOL_NAME(name);
   for (char c : name) {
-    if (isAlpha(c) || isDigit(c) || isOneOf(c, "_."))
-      continue;
-    INVALID_SYMBOL();
+    if (!isSymbolChar(c))
+      INVALID_SYMBOL_NAME(name);
   }
+  if (name == ".")
+    INVALID_SYMBOL_NAME(name);

   if (!symbols.count(name))
     symbols[name].reset(new Symbol(name));
   return symbols[name].get();
@@ -137,12 +361,12 @@

   std::string name = substr(tokens[0], 0, -1);
   if (name.size() == 1 && isDigit(name[0])) {
     curSec->labels.push_back(
-        {.name = name, .offset = curSec->offset, .line = curLine});
+        {.c = name[0], .offset = curSec->offset, .line = curLine});
   } else {
     if (getSymbol(name))
-      DUPLICATED_SYMBOL();
+      DUPLICATED_SYMBOL_NAME();
     Symbol *sym = addSymbol(name);
     sym->sec = curSec;
     sym->offset = curSec->offset;
   }
@@ -176,9 +400,9 @@
   for (unsigned i = 0; i < s.size(); ++i) {

 #define UNEXPECTED_CHAR()                                                      \
   THROW(AssemblyError, "unexpected character", curLine + 1, i + 1, c,          \
-        toHexStr(c))
+        toHexStr(c, true))

     char c = s[i];
     switch (state) {
     case Begin:
@@ -206,14 +430,14 @@
         state = End;
       } else {
         UNEXPECTED_CHAR();
       }
-      tokens.push_back(s.substr(j, i - j));
+      tokens.push_back(substr(s, j, i));
       break;
     case AfterFirst:
       if (isSpace(c))
         continue;
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c)) {
+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
         state = Operand;
         j = i;
       } else if (c == '"') {
         state = Str;
@@ -229,9 +453,9 @@
         UNEXPECTED_CHAR();
       }
       break;
     case Operand:
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c) ||
+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c) ||
           isSpace(c))
         continue;
       if (c == ',') {
         state = AfterOperand;
@@ -241,14 +465,14 @@
         state = End;
       } else {
         UNEXPECTED_CHAR();
       }
-      tokens.push_back(s.substr(j, i - j));
+      tokens.push_back(substr(s, j, i));
       break;
     case AfterOperand:
       if (isSpace(c))
         continue;
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c)) {
+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
         state = Operand;
         j = i;
       } else if (c == '"') {
         state = Str;
@@ -264,9 +488,9 @@
       if (c == '\\') {
         state = StrEsc;
       } else if (c == '"') {
         state = AfterStr;
-        tokens.push_back(s.substr(j, i + 1));
+        tokens.push_back(substr(s, j, i + 1));
       } else if (c == '\n') {
         UNEXPECTED_CHAR();
       }
       break;
@@ -330,9 +554,9 @@
         UNEXPECTED_CHAR();
       }
     case Char1:
       if (c == '\'') {
-        tokens.push_back(s.substr(j, i + 1));
+        tokens.push_back(substr(s, j, i + 1));
         state = AfterStr;
       } else {
         UNEXPECTED_CHAR();
       }
diff --git a/include/util.h b/include/util.h
--- include/util.h
+++ include/util.h
@@ -35,9 +35,9 @@
   return os.str();
 }

 template <typename T>
-std::string toHexStr(T x, bool smart = true, bool ox = false) {
+std::string toHexStr(T x, bool ox = false, bool smart = true) {
   std::ostringstream os;

   unsigned n = sizeof(T);
   if (smart) {
@@ -110,5 +110,9 @@
       std::cerr << "!!! " << ex.what() << "\n";                                \
     }                                                                          \
   } while (false)

+DEFINE_EXCEPTION(Unreachable)
+
+#define UNREACHABLE(...) THROW(NAME, __VA_ARGS__)
+
 #endif
