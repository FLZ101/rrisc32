

-std::unique_ptr<Expr> Assembler::parseExpr(const std::vector<ExprToken> &tokens) {
+void Lexer::cookStatement(Token &tk) {
+  if (tk.s.front() == '.') {
+    tk.type = Token::Directive;
+    if (!checkDirective(tk.s))
+      THROW(AssemblyError, "invalid Directive", tk.s);
+  } else if (tk.s.back() == ':') {
+    tk.type = Token::Label;
+    tk.s = substr(tk.s, 0, -1);
+    if (!checkLabel(tk.s))
+      THROW(AssemblyError, "invalid Label", tk.s);
+  } else {
+    tk.type = Token::Instr;
+    if (!checkInstr(tk.s))
+      THROW(AssemblyError, "invalid Instr", tk.s);
+  }
+}
+
+bool Lexer::checkDirective(const std::string &str) {
+  if (str.size() < 2)
+    return false;
+  for (char c : str)
+    if (!isDirective(c))
+      return false;
+  return true;
+}
+
+bool Lexer::checkInstr(const std::string &str) {
+  for (char c : str)
+    if (!isInstr(c))
+      return false;
+  return true;
+}
+
+bool Lexer::checkLabel(const std::string &str) {
+  if (str.size() < 2 || isDec(str[0]))
+    return false;
+  for (char c : str)
+    if (!isLabel(c))
+      return false;
+  return true;
+}
+
+void Lexer::cookStr(Token &tk) {
+  std::string str;
+  for (unsigned i = 1; i < tk.s.size() - 1; ++i) {
+    if (tk.s[i] == '\\') {
+      switch (tk.s[++i]) {
+      case 'n':
+        str.push_back('\n');
+        break;
+      case 't':
+        str.push_back('\t');
+        break;
+      case '0':
+        str.push_back('\0');
+        break;
+      case '"':
+        str.push_back('"');
+        break;
+      case 'x':
+        i += 2;
+        str.push_back(char(parseInt(substr(tk.s, i - 1, i + 1), true)));
+        break;
+      default:
+        UNREACHABLE();
+      }
+    }
+  }
+  tk.s = str;
+}
+
+s64 Lexer::parseInt(const std::string &str, bool hex) {
+  s64 i = 0;
+  if (hex) {
+    for (char c : str) {
+      i *= 10;
+      i += c - '0';
+    }
+  } else {
+    for (char c : str) {
+      i *= 16;
+      i += isDec(c) ? (c - '0') : (c - 'a' + 10);
+    }
+  }
+  return i;
+}
+
+void Lexer::cookInt(Token &tk) {
+  if (tk.s.starts_with("0x")) {
+    tk.i = parseInt(substr(tk.s, 2), true);
+  } else {
+    tk.i = parseInt(tk.s);
+  }
+}
+
+void Assembler::run() {
+  {
+    std::fstream ifs(filename, std::ios::in | std::ios::binary);
+    if (!ifs)
+      THROW(AssemblyError, "read", filename);
+    for (std::string line; std::getline(ifs, line);)
+      lines.push_back(line);
+  }
+}
+
+std::unique_ptr<Expr>
+Assembler::parseExpr(const std::vector<ExprToken> &tokens) {
   unsigned i = 0;

-#define UNEXPECTED_TOKEN() \
-  THROW(AssemblyError, "unexpected token", curLine + 1, lines[curLine], formatExprToken(tk))
+#define UNEXPECTED_TOKEN()                                                     \
+  THROW(AssemblyError, "unexpected token", curLine + 1, lines[curLine],        \
+        formatExprToken(tk))

 #define CUR() (tokens[i])

 #define ADVANCE() (tokens[i++])

-#define EAT(type) \
-  do { const ExprToken &tk = ADVANCE(); if (tk.type != type) UNEXPECTED_TOKEN(); } while (false)
+#define EAT(type)                                                              \
+  do {                                                                         \
+    const ExprToken &tk = ADVANCE();                                           \
+    if (tk.type != type)                                                       \
+      UNEXPECTED_TOKEN();                                                      \
+  } while (false)

   std::function<std::unique_ptr<Expr>()> parse;

@@ -266,13 +452,13 @@ std::unique_ptr<Expr> Assembler::parseExpr(const std::vector<ExprToken> &tokens)
   std::unique_ptr<Expr> expr = std::move(parse());

   if (i != tokens.size() - 1)
-    THROW(AssemblyError, "residual tokens", curLine + 1, lines[curLine], formatExprToken(tokens[i]));
+    THROW(AssemblyError, "residual tokens", curLine + 1, lines[curLine],
+          formatExprToken(tokens[i]));

   return std::move(expr);
 }

-ExprVal Assembler::evalExpr(const Expr *expr) {
-}
+ExprVal Assembler::evalExpr(const Expr *expr) {}

 Symbol *Assembler::getSymbol(const std::string &name) {
   if (symbols.count(name))
@@ -372,209 +558,6 @@ void Assembler::parseLabel(const std::vector<std::string> &tokens) {
   }
 }

-void Assembler::parseInstr(const std::vector<std::string> &tokens) {}
-
-void Assembler::tokenize(std::vector<std::string> &tokens) {
-  std::string s = lines[curLine];
-  s += "\n\n";
-
-  enum {
-    Begin,
-    First,
-    AfterFirst,
-    Operand,
-    AfterOperand,
-    Str,
-    StrEsc,
-    StrEscX,
-    StrEscXX,
-    AfterStr,
-    Char,
-    CharEsc,
-    Char1,
-    Comment,
-    End
-  };
-  auto state = Begin;
-  unsigned j = 0;
-  for (unsigned i = 0; i < s.size(); ++i) {
-
-#define UNEXPECTED_CHAR()                                                      \
-  THROW(AssemblyError, "unexpected character", curLine + 1, i + 1, c,          \
-        toHexStr(c, true))
-
-    char c = s[i];
-    switch (state) {
-    case Begin:
-      if (isSpace(c))
-        continue;
-      if (isAlpha(c) || isOneOf(c, "_.")) {
-        state = First;
-        j = i;
-      } else if (c == '#') {
-        state = Comment;
-      } else if (c == '\n') {
-        state = End;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case First:
-      if (isAlpha(c) || isOneOf(c, "_.:") || isDigit(c))
-        continue;
-      if (isSpace(c)) {
-        state = AfterFirst;
-      } else if (c == '#') {
-        state = Comment;
-      } else if (c == '\n') {
-        state = End;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      tokens.push_back(substr(s, j, i));
-      break;
-    case AfterFirst:
-      if (isSpace(c))
-        continue;
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
-        state = Operand;
-        j = i;
-      } else if (c == '"') {
-        state = Str;
-        j = i;
-      } else if (c == '\'') {
-        state = Char;
-        j = i;
-      } else if (c == '#') {
-        state = Comment;
-      } else if (c == '\n') {
-        state = End;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case Operand:
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c) ||
-          isSpace(c))
-        continue;
-      if (c == ',') {
-        state = AfterOperand;
-      } else if (c == '#') {
-        state = Comment;
-      } else if (c == '\n') {
-        state = End;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      tokens.push_back(substr(s, j, i));
-      break;
-    case AfterOperand:
-      if (isSpace(c))
-        continue;
-      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
-        state = Operand;
-        j = i;
-      } else if (c == '"') {
-        state = Str;
-        j = i;
-      } else if (c == '\'') {
-        state = Char;
-        j = i;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case Str:
-      if (c == '\\') {
-        state = StrEsc;
-      } else if (c == '"') {
-        state = AfterStr;
-        tokens.push_back(substr(s, j, i + 1));
-      } else if (c == '\n') {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case StrEsc:
-      switch (c) {
-      case 'n':
-      case 't':
-      case '0':
-      case '"':
-        state = Str;
-        break;
-      case 'x':
-        state = StrEscX;
-        break;
-      default:
-        UNEXPECTED_CHAR();
-      }
-    case StrEscX:
-      if (isOneOf(c, "0123456789abcdef"))
-        state = StrEscXX;
-      else
-        UNEXPECTED_CHAR();
-      break;
-    case StrEscXX:
-      if (isOneOf(c, "0123456789abcdef"))
-        state = Str;
-      else
-        UNEXPECTED_CHAR();
-      break;
-    case AfterStr:
-      if (isSpace(c))
-        continue;
-      if (c == ',') {
-        state = AfterOperand;
-      } else if (c == '#') {
-        state = Comment;
-      } else if (c == '\n') {
-        state = End;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case Char:
-      if (c == '\\') {
-        state = CharEsc;
-      } else if (isOneOf(c, "'\n")) {
-        UNEXPECTED_CHAR();
-      } else {
-        state = Char1;
-      }
-      break;
-    case CharEsc:
-      switch (c) {
-      case 'n':
-      case 't':
-      case '0':
-      case '\'':
-        state = Char1;
-        break;
-      default:
-        UNEXPECTED_CHAR();
-      }
-    case Char1:
-      if (c == '\'') {
-        tokens.push_back(substr(s, j, i + 1));
-        state = AfterStr;
-      } else {
-        UNEXPECTED_CHAR();
-      }
-      break;
-    case Comment:
-      if (c == '\n')
-        state = End;
-      break;
-    case End:
-      for (std::string &s : tokens) {
-        s = trim(s);
-        assert(!s.empty());
-      }
-      return;
-    }
-  }
-}
-
 Section *Assembler::getSection(const std::string &name) {
   for (Section &sec : sections)
     if (sec.name == name)
diff --git a/tmp.diff b/tmp.diff
index 72b8ab8..1f92988 100644
--- a/tmp.diff
+++ b/tmp.diff
@@ -1,561 +0,0 @@
-diff --git a/include/assembly.h b/include/assembly.h
---- include/assembly.h
-+++ include/assembly.h
-@@ -15,9 +15,9 @@
-
- DEFINE_EXCEPTION(AssemblyError)
-
- struct Label {
--  std::string name;
-+  char c;
-   s64 offset;
-   unsigned line;
- };
-
-@@ -36,29 +36,16 @@
-
-   Section(const Section &) = delete;
-   Section &operator=(const Section &) = delete;
-
--  Label *findLabelB(const std::string &name, unsigned line) {
--    auto r = std::ranges::find_last_if(
--        labels.begin(), labels.end(), [&name, line](const Label &label) {
--          return label.name == name && label.line < line;
--        });
--    return r.empty() ? nullptr : &*r.begin();
--  }
-+  const Label *findLabelB(char c, unsigned line);
-+  const Label *findLabelF(char c, unsigned line);
-
--  Label *findLabelF(const std::string &name, unsigned line) {
--    auto r = std::ranges::find_last_if(
--        labels.rbegin(), labels.rend(), [&name, line](const Label &label) {
--          return label.name == name && label.line > line;
--        });
--    return r.empty() ? nullptr : &*r.begin();
--  }
--
-   std::string name;
-   s64 offset = 0;
-   u8 align = 3;
-
--  std::list<Label> labels;
-+  std::vector<Label> labels;
-   std::list<Instr> instrs;
-   std::list<Directive> directives;
- };
-
-@@ -87,38 +74,28 @@
-   s64 offset = 0;
- };
-
- struct Expr {
--  Expr() {}
-+  enum Type { Int, Sym, Func};
-
--  s64 i;
-+  Expr(s64 i) : i(i), type(Int) {}
-+  Expr(const std::string &s, Type type = Sym) : s(s), type(type) {}
-
--  std::string sym;
-+  Type type;
-
--  std::string func;
-+  s64 i;
-+  std::string s;
-   std::vector<std::unique_ptr<Expr>> arguments;
- };
-
- struct ExprToken {
--  enum Type { Int, Sym, LPar, RPar, Func };
-+  enum Type { Int, Sym, LPar, RPar, Func, Err };
-
-+  Type type;
-   s64 i;
-   std::string s;
- };
-
--class ExprLexer {
--public:
--  ExprLexer(const std::string &s) : s(s) {}
--
--  bool hasNext();
--  void next();
--
--private:
--  std::string s;
--};
--
--// ExprParser
--
- class Assembler {
- public:
-   explicit Assembler(std::string filename)
-       : filename(filename), writer(filename + ".o", elf::ET_REL) {}
-@@ -145,21 +122,33 @@
-   }
-
-   bool isSpace(char c) { return isOneOf(c, "\t "); }
-
--  bool isOperator(char c) { return isOneOf(c, "+-*/%()<>|&^~"); }
-+  bool isOperatorChar(char c) { return isOneOf(c, "+-*/%()<>|&^~"); }
-
-+  bool isSymbolChar(char c) { return isAlpha(c) || isDigit(c) || isOneOf(c, "_."); }
-+
-   void tokenize(std::vector<std::string> &tokens);
-
-   void parseDirective(const std::vector<std::string> &tokens);
-   void parseLabel(const std::vector<std::string> &tokens);
-   void parseInstr(const std::vector<std::string> &tokens);
-
-+  void tokenizeExpr(std::string s, std::vector<ExprToken> &tokens);
-+  std::unique_ptr<Expr> parseExpr(const std::vector<ExprToken> &tokens);
-+  std::unique_ptr<Expr> parseExpr(const std::string &s);
-+  ExprVal evalExpr(const Expr *expr);
-+
-+  s64 parseInt(std::string s);
-+  s64 parseInt(char c, bool hex = false);
-+
-   Section *getSection(const std::string &name);
-
-   Symbol *getSymbol(const std::string &name);
-   Symbol *addSymbol(const std::string &name);
-
-+  bool isLocalSymbolName(const std::string &name) { return name.starts_with(".L"); }
-+
-   std::vector<std::string> lines;
-   unsigned curLine = 0;
-
-   Section sections[4] = {Section(".text"), Section(".rodata"), Section(".data"),
-@@ -176,19 +165,4 @@
-
- } // namespace assembly
-
- #endif
--
--/*
--register x0
--imm .
--
--expression
--+ - * / %
--| & ^ ~
--*/
--
--/*
--1:
--        auipc	a0, %pcrel_hi(msg + 1)
--        addi	a0, a0, %pcrel_lo(1b)
--*/
-diff --git a/CMakeLists.txt b/CMakeLists.txt
---- CMakeLists.txt
-+++ CMakeLists.txt
-@@ -3,9 +3,9 @@
-     VERSION 0.1.0
-     LANGUAGES C CXX
- )
-
--set(CMAKE_CXX_STANDARD 23)
-+set(CMAKE_CXX_STANDARD 20)
- set(CMAKE_CXX_STANDARD_REQUIRED True)
-
- set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
-
-diff --git a/lib/assembly.cpp b/lib/assembly.cpp
---- lib/assembly.cpp
-+++ lib/assembly.cpp
-@@ -1,14 +1,16 @@
- #include "assembly.h"
-
-+#include <algorithm>
- #include <fstream>
-+#include <functional>
-
- namespace assembly {
-
--#define INVALID_SYMBOL()                                                       \
--  THROW(AssemblyError, "invalid symbol", curLine + 1, lines[curLine])
-+#define INVALID_SYMBOL_NAME(name)                                                       \
-+  THROW(AssemblyError, "invalid symbol", curLine + 1, name)
-
--#define DUPLICATED_SYMBOL()                                                    \
-+#define DUPLICATED_SYMBOL_NAME()                                                    \
-   THROW(AssemblyError, "duplicated symbol", curLine + 1, lines[curLine])
-
- #define UNKNOWN_SECTION_NAME()                                                 \
-   THROW(AssemblyError, "unknown section name", curLine + 1, lines[curLine])
-@@ -27,8 +29,26 @@
-
- #define UNKNOWN_DIRECTIVE()                                                    \
-   THROW(AssemblyError, "unknown directive", curLine + 1, lines[curLine])
-
-+const Label *Section::findLabelB(char c, unsigned line) {
-+  auto it = std::lower_bound(labels.begin(), labels.end(),
-+    [](const Label &a, const Label &b) { return a.line < b.line; });
-+  while (--it >= labels.begin())
-+    if (it->c == c)
-+      return &*it;
-+  return nullptr;
-+}
-+
-+const Label *Section::findLabelF(char c, unsigned line) {
-+  auto it = std::lower_bound(labels.begin(), labels.end(),
-+    [](const Label &a, const Label &b) { return a.line <= b.line; });
-+  while (it < labels.end())
-+    if (it->c == c)
-+      return &*it;
-+  return nullptr;
-+}
-+
- void Assembler::run() {
-   {
-     std::fstream ifs(filename, std::ios::in | std::ios::binary);
-     if (!ifs)
-@@ -50,22 +70,226 @@
-       parseInstr(tokens);
-   }
- }
-
-+s64 Assembler::parseInt(char c, bool hex) {
-+  if (isDigit(c))
-+    return c - '0';
-+  if (hex && isOneOf(c, "abcdef"))
-+    return c - 'a';
-+  UNREACHABLE();
-+}
-+
-+s64 Assembler::parseInt(std::string s) {
-+  bool hex = false;
-+  if (s.starts_with("0x")) {
-+    s = substr(s, 2);
-+    hex = true;
-+  }
-+  s64 res = 0;
-+  for (char c : s) {
-+    res *= hex ? 16 : 10;
-+    res += parseInt(c, hex);
-+  }
-+  return res;
-+}
-+
-+void Assembler::tokenizeExpr(std::string s, std::vector<ExprToken> &tokens) {
-+  s += "\n\n";
-+
-+  enum {
-+    Begin,
-+    Int,
-+    Hex,
-+    Sym,
-+    Func,
-+    End
-+  };
-+  auto state = Begin;
-+  unsigned j = 0;
-+  for (unsigned i = 0; i < s.size(); ++i) {
-+    char c = s[i];
-+
-+#define UNEXPECTED_CHAR() \
-+  THROW(AssemblyError, "unexpected character", curLine + 1, s, i, c, toHexStr(c, true))
-+
-+#define INVALID_SYM_TOKEN(tk) \
-+  THROW(AssemblyError, "invalid Sym token", curLine + 1, tk)
-+
-+#define INVALID_INT_TOKEN(tk) \
-+  THROW(AssemblyError, "invalid Int token", curLine + 1, tk)
-+
-+    switch (state) {
-+    case Begin:
-+      if (isSpace(c))
-+        continue;
-+      if (isDigit(c)) {
-+        j = i;
-+        if (c == '0' && i + 1 < s.size() && s[i+1] == 'x') {
-+          state = Hex;
-+          ++i;
-+        } else {
-+          state = Int;
-+        }
-+      } else if (c == '$') {
-+        j = i;
-+        state = Sym;
-+      } else if (isAlpha(c) || isOperatorChar(c) || c == '_') {
-+        j = i;
-+        state = Func;
-+      } else if (c == '\n') {
-+        state = End;
-+      } else if (c == '(') {
-+        toke.push_back({.type = ExprToken::LPar});
-+      } else if (c == ')') {
-+        toke.push_back({.type = ExprToken::RPar});
-+      } else {
-+        UNEXPECTED_CHAR();
-+      }
-+      break;
-+    case Int:
-+    case Hex:
-+      if (isDigit(c))
-+        continue;
-+      if (state == Hex && isOneOf("abcdef"))
-+        continue;
-+      if (isSpace(c) || isOneOf(c, "()\n")) {
-+        std::string tk = substr(s, j, i);
-+        if (tk == "0x")
-+          INVALID_INT_TOKEN(tk);
-+        tokens.push_back({.type = ExprToken::Int, .i = parseInt(tk)});
-+        --i;
-+        state = Begin;
-+      } else {
-+        UNEXPECTED_CHAR();
-+      }
-+      break;
-+    case Sym:
-+      if (isSymbolChar(c))
-+        continue;
-+      if (isSpace(c) || isOneOf(c, "()\n")) {
-+        std::string tk = substr(s, j, i);
-+        if (tk.size() < 2)
-+          INVALID_SYM_TOKEN(tk);
-+        if (isDigit(tk[1])) {
-+          if (tk.size() != 3 || !isOneOf(tk[2], "bf"))
-+            INVALID_SYM_TOKEN(tk);
-+        }
-+        tokens.push_back({.type = ExprToken::Sym, .s = substr(tk, 1)});
-+        --i;
-+        state = Begin;
-+      } else {
-+        UNEXPECTED_CHAR();
-+      }
-+      break;
-+    case Func:
-+      if (isAlpha(c) || isOperatorChar(c) || c == '_' || isDigit(c))
-+        continue;
-+      if (isSpace(c) || isOneOf(c, "()\n")) {
-+        tokens.push_back({.type = ExprToken::Func, .s =substr(s, j, i)});
-+        --i;
-+        state = Begin;
-+      } else {
-+        UNEXPECTED_CHAR();
-+      }
-+      break;
-+    case End:
-+      tokens.push_back({.type = ExprToken::Err);
-+      return;
-+    }
-+  }
-+}
-+
-+std::unique_ptr<Expr> Assembler::parseExpr(const std::string &s) {
-+  std::vector<ExprToken> tokens;
-+  tokenizeExpr(s, tokens);
-+  return parseExpr(tokens);
-+}
-+
-+static std::string formatExprToken(const ExprToken &tk) {
-+  switch (tk.type) {
-+  case ExprToken::Int:
-+    return join("|", "Int", tk.i);
-+  case ExprToken::Sym:
-+    return join("|", "Sym", tk.s);
-+  case ExprToken::LPar:
-+    return "(";
-+  case ExprToken::RPar:
-+    return ")";
-+  case ExprToken::Func:
-+    return join("|", "Func", tk.s);
-+  case ExprToken::Err:
-+    return "Err";
-+  default:
-+    UNREACHABLE();
-+  }
-+}
-+
-+std::unique_ptr<Expr> Assembler::parseExpr(const std::vector<ExprToken> &tokens) {
-+  unsigned i = 0;
-+
-+#define UNEXPECTED_TOKEN() \
-+  THROW(AssemblyError, "unexpected token", curLine + 1, lines[curLine], formatExprToken(tk))
-+
-+#define CUR() (tokens[i])
-+
-+#define ADVANCE() (tokens[i++])
-+
-+#define EAT(type) \
-+  do { const ExprToken &tk = ADVANCE(); if (tk.type != type) UNEXPECTED_TOKEN(); } while (false)
-+
-+  std::function<std::unique_ptr<Expr>()> parse;
-+
-+  parse = [&tokens, &i]() -> std::unique_ptr<Expr> {
-+    const ExprToken &tk = ADVANCE();
-+    switch (tk.type) {
-+    case ExprToken::Int:
-+      return std::move(std::make_unique<Expr>(tk->i));
-+    case ExprToken::Sym:
-+      return std::move(std::make_unique<Expr>(tk->s));
-+    case ExprToken::Func: {
-+      auto expr = std::make_unique<Expr>(tk->s, Expr::Func);
-+      EAT(ExprToken::LPar);
-+      while (true) {
-+        if (CUR().type == ExprToken::RPar) {
-+          ADVANCE();
-+          break;
-+        }
-+        expr->arguments.emplace_back(std::move(parse()));
-+      }
-+      return std::move(expr);
-+    }
-+    default:
-+      UNEXPECTED_TOKEN();
-+    }
-+  };
-+
-+  std::unique_ptr<Expr> expr = std::move(parse());
-+
-+  if (i != tokens.size() - 1)
-+    THROW(AssemblyError, "residual tokens", curLine + 1, lines[curLine], formatExprToken(tokens[i]));
-+
-+  return std::move(expr);
-+}
-+
-+ExprVal Assembler::evalExpr(const Expr *expr) {
-+}
-+
- Symbol *Assembler::getSymbol(const std::string &name) {
-   if (symbols.count(name))
-     return symbols[name].get();
-   return nullptr;
- }
-
- Symbol *Assembler::addSymbol(const std::string &name) {
-   if (isDigit(name[0]))
--    INVALID_SYMBOL();
-+    INVALID_SYMBOL_NAME(name);
-   for (char c : name) {
--    if (isAlpha(c) || isDigit(c) || isOneOf(c, "_."))
--      continue;
--    INVALID_SYMBOL();
-+    if (!isSymbolChar(c))
-+      INVALID_SYMBOL_NAME(name);
-   }
-+  if (name == ".")
-+    INVALID_SYMBOL_NAME(name);
-
-   if (!symbols.count(name))
-     symbols[name].reset(new Symbol(name));
-   return symbols[name].get();
-@@ -137,12 +361,12 @@
-
-   std::string name = substr(tokens[0], 0, -1);
-   if (name.size() == 1 && isDigit(name[0])) {
-     curSec->labels.push_back(
--        {.name = name, .offset = curSec->offset, .line = curLine});
-+        {.c = name[0], .offset = curSec->offset, .line = curLine});
-   } else {
-     if (getSymbol(name))
--      DUPLICATED_SYMBOL();
-+      DUPLICATED_SYMBOL_NAME();
-     Symbol *sym = addSymbol(name);
-     sym->sec = curSec;
-     sym->offset = curSec->offset;
-   }
-@@ -176,9 +400,9 @@
-   for (unsigned i = 0; i < s.size(); ++i) {
-
- #define UNEXPECTED_CHAR()                                                      \
-   THROW(AssemblyError, "unexpected character", curLine + 1, i + 1, c,          \
--        toHexStr(c))
-+        toHexStr(c, true))
-
-     char c = s[i];
-     switch (state) {
-     case Begin:
-@@ -206,14 +430,14 @@
-         state = End;
-       } else {
-         UNEXPECTED_CHAR();
-       }
--      tokens.push_back(s.substr(j, i - j));
-+      tokens.push_back(substr(s, j, i));
-       break;
-     case AfterFirst:
-       if (isSpace(c))
-         continue;
--      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c)) {
-+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
-         state = Operand;
-         j = i;
-       } else if (c == '"') {
-         state = Str;
-@@ -229,9 +453,9 @@
-         UNEXPECTED_CHAR();
-       }
-       break;
-     case Operand:
--      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c) ||
-+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c) ||
-           isSpace(c))
-         continue;
-       if (c == ',') {
-         state = AfterOperand;
-@@ -241,14 +465,14 @@
-         state = End;
-       } else {
-         UNEXPECTED_CHAR();
-       }
--      tokens.push_back(s.substr(j, i - j));
-+      tokens.push_back(substr(s, j, i));
-       break;
-     case AfterOperand:
-       if (isSpace(c))
-         continue;
--      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperator(c)) {
-+      if (isAlpha(c) || isDigit(c) || isOneOf(c, "_.$") || isOperatorChar(c)) {
-         state = Operand;
-         j = i;
-       } else if (c == '"') {
-         state = Str;
-@@ -264,9 +488,9 @@
-       if (c == '\\') {
-         state = StrEsc;
-       } else if (c == '"') {
-         state = AfterStr;
--        tokens.push_back(s.substr(j, i + 1));
-+        tokens.push_back(substr(s, j, i + 1));
-       } else if (c == '\n') {
-         UNEXPECTED_CHAR();
-       }
-       break;
-@@ -330,9 +554,9 @@
-         UNEXPECTED_CHAR();
-       }
-     case Char1:
-       if (c == '\'') {
--        tokens.push_back(s.substr(j, i + 1));
-+        tokens.push_back(substr(s, j, i + 1));
-         state = AfterStr;
-       } else {
-         UNEXPECTED_CHAR();
-       }
-diff --git a/include/util.h b/include/util.h
---- include/util.h
-+++ include/util.h
-@@ -35,9 +35,9 @@
-   return os.str();
- }
-
- template <typename T>
--std::string toHexStr(T x, bool smart = true, bool ox = false) {
-+std::string toHexStr(T x, bool ox = false, bool smart = true) {
-   std::ostringstream os;
-
-   unsigned n = sizeof(T);
-   if (smart) {
-@@ -110,5 +110,9 @@
-       std::cerr << "!!! " << ex.what() << "\n";                                \
-     }                                                                          \
-   } while (false)
-
-+DEFINE_EXCEPTION(Unreachable)
-+
-+#define UNREACHABLE(...) THROW(NAME, __VA_ARGS__)
-+
- #endif
diff --git a/tools/assemble/main.cpp b/tools/assemble/main.cpp
index 95828e9..8aa64f1 100644
--- a/tools/assemble/main.cpp
+++ b/tools/assemble/main.cpp
@@ -4,7 +4,7 @@ using namespace assembly;

 int main(int argc, char *argv[]) {
   CATCH(
-    Assembler as("/media/d/work/llvm/rrisc32/test/tools/assemble/hello.s");
+    Assembler as("test/tools/assemble/hello.s");
     as.run()
   );
 }
